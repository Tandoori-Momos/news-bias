{"version":3,"sources":["../../src/utils/tokenize.js"],"names":["nlp","require","distinctArray","array","i","length","j","includes","splice","tokenize","sentence","options","returnType","tokens","doc","sentences","toPresentTense","toPositive","nouns","toSingular","normalize","out","topics","titlecased","clauses","match","Array","prototype","concat","apply","join","console","log"],"mappings":";;;;;;;;AAAA,IAAMA,MAAMC,QAAQ,YAAR,CAAZ;;AAEA;AACA,SAASC,aAAT,CAAwBC,KAAxB,EAA+B;AAC3B,SAAK,IAAIC,IAAID,MAAME,MAAN,GAAe,CAA5B,EAA+BD,KAAI,CAAnC,EAAuCA,GAAvC,EAA4C;AACxC,aAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIF,CAApB,EAAuBE,GAAvB,EAA4B;AACzB,gBAAGH,MAAMG,CAAN,EAASC,QAAT,CAAkBJ,MAAMC,CAAN,CAAlB,CAAH,EAAgC;AAC3BD,sBAAMK,MAAN,CAAaJ,CAAb,EAAe,CAAf;AACJ;AACH;AACJ;AACD,WAAOD,KAAP;AACH;;AAED,IAAMM,WAAW,SAAXA,QAAW,CAASC,QAAT,EAAkD;AAAA,QAA/BC,OAA+B,uEAAvB,EAACC,YAAW,QAAZ,EAAuB;;AAC/D;AACA;AACA;;AAEA,QAAIC,SAAS,EAAb;AACA,QAAIC,MAAMd,IAAIU,QAAJ,CAAV;;AAEA;AACA;AACAI,QAAIC,SAAJ,GAAgBC,cAAhB,GACKC,UADL,GAEKC,KAFL,GAEaC,UAFb,GAGKC,SAHL;;AAKA;AACA,QAAIF,QAAQJ,IAAII,KAAJ,GAAYG,GAAZ,CAAgB,OAAhB,CAAZ;;AAEA;AACA,QAAIC,SAASR,IAAIQ,MAAJ,GAAaD,GAAb,CAAiB,OAAjB,CAAb;AACA;AACA,QAAIE,aAAaT,IAAIU,OAAJ,GAAcC,KAAd,CAAoB,aAApB,EAAmCJ,GAAnC,CAAuC,OAAvC,CAAjB;;AAEA;AACAR,wDAAaA,MAAb,IAAqBK,KAArB,EAA4BI,MAA5B,EAAoCC,UAApC;;AAEA;AACAV,aAASa,MAAMC,SAAN,CAAgBC,MAAhB,CAAuBC,KAAvB,CAA6B,EAA7B,EAAiChB,MAAjC,CAAT;;AAEA;AACA;AACA,QAAIF,QAAQC,UAAR,KAAuB,OAA3B,EAAoC;AAChC,eAAOC,MAAP;AACH,KAFD,MAEO,IAAIF,QAAQC,UAAR,KAAuB,QAA3B,EAAqC;AACxC,eAAOC,OAAOiB,IAAP,CAAY,GAAZ,CAAP;AACH,KAFM,MAEA,IAAInB,QAAQC,UAAR,KAAuB,KAA3B,EAAkC;AACrC,eAAOC,OAAOiB,IAAP,CAAY,GAAZ,CAAP;AACH;AACJ,CAtCD;;AAyCAC,QAAQC,GAAR,CAAYvB,SAAS,qBAAT,EAAgC,EAAEG,YAAY,OAAd,EAAhC,CAAZ","file":"tokenize.js","sourcesContent":["const nlp = require('compromise');\r\n\r\n// Returns an array whose each element is distinct\r\nfunction distinctArray (array) {\r\n    for (let i = array.length - 1; i >=0 ; i--) {\r\n        for (let j = 0; j < i; j++) {\r\n           if(array[j].includes(array[i])) {\r\n                array.splice(i,1);\r\n           }\r\n        }\r\n    }    \r\n    return array;\r\n}\r\n\r\nconst tokenize = function(sentence, options={returnType:'string'}) {   \r\n    // Returns an object of keywords containing\r\n    // nouns, places, people, topics, titlecased words\r\n    // which can be used to replicate search results\r\n\r\n    let tokens = [];\r\n    let doc = nlp(sentence);\r\n\r\n    // Convert the sentence to present tense, \r\n    // singular and affirmative\r\n    doc.sentences().toPresentTense()\r\n        .toPositive()\r\n        .nouns().toSingular()\r\n        .normalize();\r\n\r\n    // Grab all nouns\r\n    let nouns = doc.nouns().out('array');\r\n\r\n    // Grab all default named entities\r\n    let topics = doc.topics().out('array');\r\n    // Grab all titlecased words \r\n    let titlecased = doc.clauses().match('#TitleCase+').out('array');\r\n    \r\n    // Add all the arrays to the token array \r\n    tokens = [...tokens, nouns, topics, titlecased];\r\n\r\n    // Flatten the array \r\n    tokens = Array.prototype.concat.apply([], tokens);\r\n\r\n    // Return the tokens in different formats based on \r\n    // what the return type mentioned is in function call\r\n    if (options.returnType === 'array') {\r\n        return tokens;\r\n    } else if (options.returnType === 'string') {\r\n        return tokens.join(' ');\r\n    } else if (options.returnType === 'url') {\r\n        return tokens.join('+');\r\n    }\r\n}\r\n\r\n\r\nconsole.log(tokenize('YASH wardhann kumar', { returnType: 'array' }));"]}